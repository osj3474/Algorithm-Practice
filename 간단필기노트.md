# 개념 메모 2



큰 문제를 작은 문제로 나누어서 푸는 것

- Dynamic Programming : 작은 문제들이 중복이 가능함.
- Divide & Conquer : 작은 문제들이 중복이 가능하지 않음.



# 다이나믹 프로그래밍

### [ 조건 ] 

1. Overlapping Subproblem

   : 작은 문제들이 중복이 된다.

   : 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.

   : 문제를 작은 문제로 쪼갤 수 있다.

   ex) N번째 피보나치 수 구하기

   

2. Optimal Substructure

   : 문제의 정답이 작은 문제의 정답으로 풀 수 있다.

   : 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.

   

### [ 메모라이제이션 ]

1. 같은 문제는 정답이 같기 때문에, 정답을 저장해둔다.



```c
int memo[100];
int fibonacci(int n){
  if(n<=1){
    return n;
  }else{
    if(memo[n]!=0){
      return memo[n];
    }
    memo[n] = fibonacci(n-1)+fibonacci(n-2);
    return memo[n];
  }
}
```

memo를 추가해서 모든 문제를 1번식만 푼다면, 시간복잡도가 O(2^n) => O(n)

cf) 시간복잡도 : 함수의 호출 횟수(문제의 갯수) * 함수의 시간복잡도(문제 1개 푸는데 필요한 시간)



### [ 구현 ]

1. Top-down 

   : 재귀

   cf) 재귀는 base case + recursive case의 조합으로 구성된다.

2. Bottom-up

   : 반복문 (작은 문제부터 품)





### [ 점화식 ]

: 단계 하나랑 나머지 전체 단계

 







```
gem install eventmachine -v '1.2.7' --source 'https://rubygems.org/'
```







