# 코딩테스트

### 1. binary search 

##### [ non-recursive ]

```python
target = 10
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)
lst.sort()

while low <= high:
    mid = (low+high) // 2
    if lst[mid] == target:
        break
    elif lst[mid] < target:
        low = mid + 1
    else:
        high = mid - 1

print(mid)
print(lst[mid])
```



##### [ recursive ]

```python
target = 10
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)
lst.sort()

def binary_search(data, target, low, high):
    mid = (low+high) // 2
    if data[mid] == target:
        pass
    elif data[mid] < target:
        binary_search(data, target, mid+1, high)
    elif data[mid] > target:
        binary_search(data, target, low, mid-1)
    return mid

idx = binary_search(lst, target, low, high)
print(idx)
print(lst[idx])
```



### 2. (리스트) 어느 수보다 작은 element들 찾기

```python
target = 9
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)

lst.sort()
while low<=high:
    mid = (low+high) // 2
    if lst[mid] == target:
        break
    elif lst[mid] < target:
        low = mid + 1
    else:
        high = mid - 1
        
idx = 0
if lst[mid] < target:
    idx = mid
else:
    idx = mid - 1
print(idx)
print(lst[idx])
```



### 3. 에라토스테네스의 체

##### [ 기본 ]

```python
def era(N):
    ck = [False for _ in range(N+1)]
    ret = []
    for i in range(2, len(ck)):
        if ck[i]:
            continue
        ret.append(i)
        for j in range(i**2, len(ck), i):
            ck[j] = True
    return ret

print(era(10))
```

##### [ 소수만 True인 리스트 반환 ]

```python
def era(N):
    ck = [False for _ in range(N+1)]
    ret = [False for _ in range(N+1)]
    for i in range(2, len(ck)):
        if ck[i]:
            continue
        ret[i] = True
        for j in range(i*2, len(ck), i):
            ck[j] = True
    return ret

print(era(10))
```





### 4. 두 수 범위 안에 있는 element 찾기

```python

```





### 5. 딕셔너리 활용하기 (프로그래머스 고득점kit 해시1)

##### [ 문제 ]

participant은 n개의 string으로 이루어진 리스트, completion은 n-1개의 string으로 이루어진 리스트이다. participant - completion의 string을 구하시오.

##### [ 전략 ]

해시를 활용하는 문제로, 파이썬의 딕셔너리를 적극 활용하였다. 

- **par_dic** : *딕셔너리*, key=participant의 string, value=string의 index
- **ck** : *리스트*, participant의 길이만큼의 길이를 가지며, completion에 있는 string이면 True, 아니면, False

```python
def solution(participant, completion):
    ck = [False for _ in range(len(participant))] 
    par_dic = {}
    participant.sort()
    completion.sort()
    for i in range(len(participant)):  # par_dic을 만들 때, key에 여러 value가 들어갈 수 있도록 조치
        if participant[i] in par_dic:
            new.append(i)
        else:
            new = [i]
        par_dic[participant[i]]=new
    for i in range(len(completion)):   # completion을 하나하나 보면서, ck를 완성하고, False인 element 반환
        ck[par_dic.get(completion[i]).pop(0)] = True
    idx = ck.index(False)
    return participant[idx]
```



### 6. 출력 관련

##### [ 소수점 ] - round

```python
import math
print(round(math.pi, 6))    # 3.141593  (6번 째까지 '반올림'을 통해 보여지게)
```

##### [ 소수점 ] - format

```python 
print("{:1.3f}".format(a))    # {인덱스(생략가능):최소숫자길이(생략가능).소수점몇개까지f}
```



### 7. 최대, 최솟값 관련된 것은 Heap으로!

그러면 생각할 때, 어떤 회사가 최대, 최소에 민감할지를 생각해봐야겠다. (내비게이션 관련 회사라면 그래프가 중요한 것처럼)

Max Heap 기준으로 특징 2가지

- 부모 노드가 자식 노드보다 크다.
- 자식 노드의 left, right는 어느 쪽이 크더라도 상관없다.



완전 이진트리라서, 파이썬에서는 리스트로 구현한다. class를 만들고 안에 function을 구현해서 사용하자.

#### Function

##### 1. Insert

일단, 완전 이진 트리 구조로 넣고, heap 구조를 만족하도록 swap한다.

##### 2. pop

heap에서의 pop은 root노드를 pop하는 것이다. pop 후에, 맨 마지막에 채워진 노드를 root노드로 올리고, 자식 노드 중 큰 자식 노드와 비교해서 swap해간다.

##### 

#### 구현 시 key point

##### 1. 인덱스

- 부모 노드 index : 자식 노드 index // 2
- 왼쪽 자식 노드 index : 부모 노드 index * 2
- 오른쪽 자식 노드 index : 부모 노드 index * 2 + 1 



#### 라이브러리

기본적으로 파이썬에서의 heap은 min heap입니다. 넣고 빼는 함수는 heapq를 이용하되, 함수의 인자가 되는 대상은 항상 리스트입니다. 

**_min heap_**

```python
import heapq as hq

hq.heapify(리스트)        # 리스트 -> 힙, return 없음, O(N)
hq.heappush(리스트, 원소)  # 원소 추가, return 없음, O(logN)
hq.heappop(리스트)        # 원소 삭제, return 원소, O(logN)
```



**_max heap_**

우선순위 heap처럼 heap을 구성합니다. 

```python
a = [(2, 3), (1, 5), (3, 2)]
a.sort()
print(a)

# 결과 : [(1, 5), (2, 3), (3, 2)]
```

위의 정렬을 생각해보면, 

```python
import heapq as hq

a = [3, 5, 2]

for i in range(len(a)):
    a[i] = (a[i]*(-1), a[i])
hq.heapify(a)
print(a)

# 결과 : [(-5, 5), (-3, 3), (-2, 2)]
```



### 8. Queue

일반 deque를 사용법을 먼저 이해합시다. deque는 double ended queue로, 양단에서 pop, push가 됩니다.

```python
from collections import deque

a = [2, 4, 3]
de = deque(a)    # 기존의 리스트로 deque를 생성
de.append(1)     # 오른쪽에 값 추가
de.appendleft(5) # 왼쪽에 값 추가

b = [7, 8]
de.extend(b)     # 오른쪽에 리스트 추가 
de.extendleft(b) # 왼쪽에 리스트 추가

de.pop()         # 오른쪽에 값 제거
de.popleft()     # 왼쪽에 값 제거

de.rotate(3)     # 오른쪽으로 3만큼 회전
de.rotate(-1)    # 왼쪽으로 1만큼 회전
```



그리고, 우선순위 queue를 봅시다.

```python 
from queue import PriorityQueue

queue = PriorityQueue()   # 생성
queue.put((1, 'love'))    # 원소 추가 '(우선순위, 값)꼴', O(logN)
queue.put((2, 'faith'))
queue.put((3, 'hope'))

queue.get()               # 그 중에 제일은 사랑이라 (고린도전서 13:13)
queue.qsize()             # queue의 사이즈를 반환
queue.empty()             # 비었는지 T or F
```





### 9. combination & permutation

```python
from itertools import combinations
from itertools import permutations

a = [1, 4, 65, 7, 2]
print(list(combinations(a,3 )))
```



### 10. DFS, BFS

```python
graph = dict()

graph['A'] = ['B', 'C']
graph['B'] = ['A', 'D']
graph['C'] = ['A', 'G', 'H', 'I']
graph['D'] = ['B', 'E', 'F']
graph['E'] = ['D']
graph['F'] = ['D']
graph['G'] = ['C']
graph['H'] = ['C']
graph['I'] = ['C', 'J']
graph['J'] = ['I']

def DFS(graph, start_node):
    need, visited = list(), list()
    need.append(start_node)
    while need:
        now = need.pop()
        if now not in visited:
            visited.append(now)
            need.extend(reversed(graph[now]))
    return visited

from collections import deque
def BFS(graph, start_node):
    need, visited = deque(), list()
    need.append(start_node)
    while need:
        now = need.popleft()
        if now not in visited:
            visited.append(now)
            need.extend(graph[now])
    return visited

print(DFS(graph, "A"))
print(BFS(graph, "A"))

```



# SQL

### 1. 차집합

프로그래머스 JOIN1.sql

```mysql
SELECT ANIMAL_ID, NAME FROM ANIMAL_OUTS
WHERE ANIMAL_ID NOT IN
    (SELECT DISTINCT ANIMAL_ID 
     FROM ANIMAL_INS);
```



### 2. 정렬

만약, VARCHAR라서 정렬을 못하는 상황이라면

```mysql

```

