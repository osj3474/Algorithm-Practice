# 코딩테스트

### 1. binary search 

##### [ non-recursive ]

```python
target = 10
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)
lst.sort()

while low <= high:
    mid = (low+high) // 2
    if lst[mid] == target:
        break
    elif lst[mid] < target:
        low = mid + 1
    else:
        high = mid - 1

print(mid)
print(lst[mid])
```



##### [ recursive ]

```python
target = 10
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)
lst.sort()

def binary_search(data, target, low, high):
    mid = (low+high) // 2
    if data[mid] == target:
        pass
    elif data[mid] < target:
        binary_search(data, target, mid+1, high)
    elif data[mid] > target:
        binary_search(data, target, low, mid-1)
    return mid

idx = binary_search(lst, target, low, high)
print(idx)
print(lst[idx])
```



### 2. (리스트) 어느 수보다 작은 element들 찾기

```python
target = 9
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)

lst.sort()
while low<=high:
    mid = (low+high) // 2
    if lst[mid] == target:
        break
    elif lst[mid] < target:
        low = mid + 1
    else:
        high = mid - 1
        
idx = 0
if lst[mid] < target:
    idx = mid
else:
    idx = mid - 1
print(idx)
print(lst[idx])
```



### 3. 에라토스테네스의 체

##### [ 기본 ]

```python
def era(N):
    ck = [False for _ in range(N+1)]
    ret = []
    for i in range(2, len(ck)):
        if ck[i]:
            continue
        ret.append(i)
        for j in range(i**2, len(ck), i):
            ck[j] = True
    return ret

print(era(10))
```

##### [ 소수만 True인 리스트 반환 ]

```python
def era(N):
    ck = [False for _ in range(N+1)]
    ret = [False for _ in range(N+1)]
    for i in range(2, len(ck)):
        if ck[i]:
            continue
        ret[i] = True
        for j in range(i*2, len(ck), i):
            ck[j] = True
    return ret

print(era(10))
```





### 4. 두 수 범위 안에 있는 element 찾기

```python

```





### 5. 딕셔너리 활용하기 (프로그래머스 고득점kit 해시1)

##### [ 문제 ]

participant은 n개의 string으로 이루어진 리스트, completion은 n-1개의 string으로 이루어진 리스트이다. participant - completion의 string을 구하시오.

##### [ 전략 ]

해시를 활용하는 문제로, 파이썬의 딕셔너리를 적극 활용하였다. 

- **par_dic** : *딕셔너리*, key=participant의 string, value=string의 index
- **ck** : *리스트*, participant의 길이만큼의 길이를 가지며, completion에 있는 string이면 True, 아니면, False

```python
def solution(participant, completion):
    ck = [False for _ in range(len(participant))] 
    par_dic = {}
    participant.sort()
    completion.sort()
    for i in range(len(participant)):  # par_dic을 만들 때, key에 여러 value가 들어갈 수 있도록 조치
        if participant[i] in par_dic:
            new.append(i)
        else:
            new = [i]
        par_dic[participant[i]]=new
    for i in range(len(completion)):   # completion을 하나하나 보면서, ck를 완성하고, False인 element 반환
        ck[par_dic.get(completion[i]).pop(0)] = True
    idx = ck.index(False)
    return participant[idx]
```



### 6. 출력 관련

##### [ 소수점 ] - round

```python
import math
print(round(math.pi, 6))    # 3.141593  (6번 째까지 '반올림'을 통해 보여지게)
```

##### [ 소수점 ] - format

```python 
print("{:1.3f}".format(a))    # {인덱스(생략가능):최소숫자길이(생략가능).소수점몇개까지f}
```



### 7. 최대, 최솟값 관련된 것은 Heap으로!

그러면 생각할 때, 어떤 회사가 최대, 최소에 민감할지를 생각해봐야겠다. (내비게이션 관련 회사라면 그래프가 중요한 것처럼)

Max Heap 기준으로 특징 2가지

- 부모 노드가 자식 노드보다 크다.
- 자식 노드의 left, right는 어느 쪽이 크더라도 상관없다.



완전 이진트리라서, 파이썬에서는 리스트로 구현한다. class를 만들고 안에 function을 구현해서 사용하자.

#### Function

##### 1. Insert

일단, 완전 이진 트리 구조로 넣고, heap 구조를 만족하도록 swap한다.

##### 2. pop

heap에서의 pop은 root노드를 pop하는 것이다. pop 후에, 맨 마지막에 채워진 노드를 root노드로 올리고, 자식 노드 중 큰 자식 노드와 비교해서 swap해간다.

##### 

#### 구현 시 key point

##### 1. 인덱스

- 부모 노드 index : 자식 노드 index // 2
- 왼쪽 자식 노드 index : 부모 노드 index * 2
- 오른쪽 자식 노드 index : 부모 노드 index * 2 + 1 

