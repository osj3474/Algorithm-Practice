# 코딩테스트

### 1. binary search 

##### [ non-recursive ]

```python
target = 10
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)
lst.sort()

while low <= high:
    mid = (low+high) // 2
    if lst[mid] == target:
        break
    elif lst[mid] < target:
        low = mid + 1
    else:
        high = mid - 1

print(mid)
print(lst[mid])
```



##### [ recursive ]

```python
target = 10
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)
lst.sort()

def binary_search(data, target, low, high):
    mid = (low+high) // 2
    if data[mid] == target:
        pass
    elif data[mid] < target:
        binary_search(data, target, mid+1, high)
    elif data[mid] > target:
        binary_search(data, target, low, mid-1)
    return mid

idx = binary_search(lst, target, low, high)
print(idx)
print(lst[idx])
```



### 2. (리스트) 어느 수보다 작은 element들 찾기

```python
target = 9
lst = [1, 4, 6, 8, 10, 13, 15, 16, 17, 20]

low = 0
high = len(lst)

lst.sort()
while low<=high:
    mid = (low+high) // 2
    if lst[mid] == target:
        break
    elif lst[mid] < target:
        low = mid + 1
    else:
        high = mid - 1
        
idx = 0
if lst[mid] < target:
    idx = mid
else:
    idx = mid - 1
print(idx)
print(lst[idx])
```



### 3. 에라토스테네스의 체

##### [ 기본 ]

```python
def era(N):
    ck = [False for _ in range(N+1)]
    ret = []
    for i in range(2, len(ck)):
        if ck[i]:
            continue
        ret.append(i)
        for j in range(i**2, len(ck), i):
            ck[j] = True
    return ret

print(era(10))
```

##### [ 소수만 True인 리스트 반환 ]

```python
def era(N):
    ck = [False for _ in range(N+1)]
    ret = [False for _ in range(N+1)]
    for i in range(2, len(ck)):
        if ck[i]:
            continue
        ret[i] = True
        for j in range(i*2, len(ck), i):
            ck[j] = True
    return ret

print(era(10))
```





### 4. 두 수 범위 안에 있는 element 찾기

```python

```





### 5. 딕셔너리 활용하기 (프로그래머스 고득점kit 해시1)

##### [ 문제 ]

participant은 n개의 string으로 이루어진 리스트, completion은 n-1개의 string으로 이루어진 리스트이다. participant - completion의 string을 구하시오.

##### [ 전략 ]

해시를 활용하는 문제로, 파이썬의 딕셔너리를 적극 활용하였다. 

- **par_dic** : *딕셔너리*, key=participant의 string, value=string의 index
- **ck** : *리스트*, participant의 길이만큼의 길이를 가지며, completion에 있는 string이면 True, 아니면, False

```python
def solution(participant, completion):
    ck = [False for _ in range(len(participant))] 
    par_dic = {}
    participant.sort()
    completion.sort()
    for i in range(len(participant)):  # par_dic을 만들 때, key에 여러 value가 들어갈 수 있도록 조치
        if participant[i] in par_dic:
            new.append(i)
        else:
            new = [i]
        par_dic[participant[i]]=new
    for i in range(len(completion)):   # completion을 하나하나 보면서, ck를 완성하고, False인 element 반환
        ck[par_dic.get(completion[i]).pop(0)] = True
    idx = ck.index(False)
    return participant[idx]
```



### 6. 출력 관련

##### [ 소수점 ] - round

```python
import math
print(round(math.pi, 6))    # 3.141593  (6번 째까지 '반올림'을 통해 보여지게)
```

##### [ 소수점 ] - format

```python 
print("{:1.3f}".format(a))    # {인덱스(생략가능):최소숫자길이(생략가능).소수점몇개까지f}
```



### 7. 최대, 최솟값 관련된 것은 Heap으로!

그러면 생각할 때, 어떤 회사가 최대, 최소에 민감할지를 생각해봐야겠다. (내비게이션 관련 회사라면 그래프가 중요한 것처럼)

Max Heap 기준으로 특징 2가지

- 부모 노드가 자식 노드보다 크다.
- 자식 노드의 left, right는 어느 쪽이 크더라도 상관없다.



완전 이진트리라서, 파이썬에서는 리스트로 구현한다. class를 만들고 안에 function을 구현해서 사용하자.

#### Function

##### 1. Insert

일단, 완전 이진 트리 구조로 넣고, heap 구조를 만족하도록 swap한다.

##### 2. pop

heap에서의 pop은 root노드를 pop하는 것이다. pop 후에, 맨 마지막에 채워진 노드를 root노드로 올리고, 자식 노드 중 큰 자식 노드와 비교해서 swap해간다.

##### 

#### 구현 시 key point

##### 1. 인덱스

- 부모 노드 index : 자식 노드 index // 2
- 왼쪽 자식 노드 index : 부모 노드 index * 2
- 오른쪽 자식 노드 index : 부모 노드 index * 2 + 1 



#### 라이브러리

기본적으로 파이썬에서의 heap은 min heap입니다. 넣고 빼는 함수는 heapq를 이용하되, 함수의 인자가 되는 대상은 항상 리스트입니다. 

**_min heap_**

```python
import heapq as hq

hq.heapify(리스트)        # 리스트 -> 힙, return 없음, O(N)
hq.heappush(리스트, 원소)  # 원소 추가, return 없음, O(logN)
hq.heappop(리스트)        # 원소 삭제, return 원소, O(logN)
```



**_max heap_**

우선순위 heap처럼 heap을 구성합니다. 

```python
a = [(2, 3), (1, 5), (3, 2)]
a.sort()
print(a)

# 결과 : [(1, 5), (2, 3), (3, 2)]
```

위의 정렬을 생각해보면, 

```python
import heapq as hq

a = [3, 5, 2]

for i in range(len(a)):
    a[i] = (a[i]*(-1), a[i])
hq.heapify(a)
print(a)

# 결과 : [(-5, 5), (-3, 3), (-2, 2)]
```



### 8. Queue

일반 deque를 사용법을 먼저 이해합시다. deque는 double ended queue로, 양단에서 pop, push가 됩니다.

```python
from collections import deque

a = [2, 4, 3]
de = deque(a)    # 기존의 리스트로 deque를 생성
de.append(1)     # 오른쪽에 값 추가
de.appendleft(5) # 왼쪽에 값 추가

b = [7, 8]
de.extend(b)     # 오른쪽에 리스트 추가 
de.extendleft(b) # 왼쪽에 리스트 추가

de.pop()         # 오른쪽에 값 제거
de.popleft()     # 왼쪽에 값 제거

de.rotate(3)     # 오른쪽으로 3만큼 회전
de.rotate(-1)    # 왼쪽으로 1만큼 회전
```



그리고, 우선순위 queue를 봅시다.

```python 
from queue import PriorityQueue

queue = PriorityQueue()   # 생성
queue.put((1, 'love'))    # 원소 추가 '(우선순위, 값)꼴', O(logN)
queue.put((2, 'faith'))
queue.put((3, 'hope'))

queue.get()               # 그 중에 제일은 사랑이라 (고린도전서 13:13)
queue.qsize()             # queue의 사이즈를 반환
queue.empty()             # 비었는지 T or F
```





### 9. combination & permutation

```python
from itertools import combinations
from itertools import permutations

a = [1, 4, 65, 7, 2]
print(list(combinations(a,3 )))
```



### 10. DFS, BFS

```python
graph = dict()

graph['A'] = ['B', 'C']
graph['B'] = ['A', 'D']
graph['C'] = ['A', 'G', 'H', 'I']
graph['D'] = ['B', 'E', 'F']
graph['E'] = ['D']
graph['F'] = ['D']
graph['G'] = ['C']
graph['H'] = ['C']
graph['I'] = ['C', 'J']
graph['J'] = ['I']

def DFS(graph, start_node):
    need, visited = list(), list()
    need.append(start_node)
    while need:
        now = need.pop()
        if now not in visited:
            visited.append(now)
            need.extend(reversed(graph[now]))
    return visited

from collections import deque
def BFS(graph, start_node):
    need, visited = deque(), list()
    need.append(start_node)
    while need:
        now = need.popleft()
        if now not in visited:
            visited.append(now)
            need.extend(graph[now])
    return visited

print(DFS(graph, "A"))
print(BFS(graph, "A"))

```



### 11. 파이썬 run time error (재귀)

```python
import sys
sys.setrecursionlimit(1000000)
```



### 12. DFS, BFS 

대게 **DFS는 재귀 or 스택** / **BFS는 큐**로 푼다고 합니다. 그런데, 특별한 경우가 아니면, DFS로 풀리는 것은 BFS로 풀리고, BFS로 풀리는 것은 DFS로 풀리니 일단, DFS를 재귀로 푸는 법을 연습합니다. (경우의 수 문제처럼 느껴지는 것은 이 접근법으로)

예제는 knapsack problem이고, **재귀** 로 풀도록 하겠습니다.

먼저 fast_max 라고 하는 재귀 함수를 만들 건데요. 이 함수는 영역과 남은 가방 용량을 받아서, 해당 영역에서 가장 가치가 높은 아이템 조합과 가치 총합을 반환해주는 함수입니다.

- 파라미터 : (아이템들, 남은 수용양)
- 리턴 : (아이템 조합, 가치 총합)

```python
def fast_max(sub_lst, avail) :
  	# 후보군이 될 수 있는 아이템이 없거나, 가방에 더 넣은 공간이 없다면, (아이템 조합은 없고, 가치 총합은 0)을 반환해야 합니다.
    if sub_lst == [] or avail == 0 :
        return (), 0
    # 아이템들 중에 처음 아이템을 일단 하나 선택합니다.
    nextitem = sub_lst[0]
    # 방금 꺼낸 아이템(nextitem)을 넣었을 때, 가방이 넘치치 않는 경우
    if nextitem[2] <= avail : 
        # 이제부터 전략은, 전체 sub_lst에서 방금 꺼낸 아이템(nextitem)을 포함했을 때의 조합을 chosen1이라 두고,
        # 방금 꺼낸 아이템(nextitem)을 포함하지 않고의 조합을 chosen2라 두어, 
        # 가치를 비교하게 됩니다. 
        chosen1, val1 = fast_max(sub_lst[1:], avail-nextitem[2])
        val1 += nextitem[1]
        chosen1 = chosen1 + (nextitem,)
        chosen2, val2 = fast_max(sub_lst[1:], avail)
        if val1 > val2 :
            result = chosen1, val1
        else :
            result = chosen2, val2
    # 방금 꺼낸 아이템(nextitem)을 넣었을 때, 가방이 넘치는 경우
    else :
        # nextitem을 제외하고 나머지 영역에 대해 조합을 찾습니다.
        result = fast_max(sub_lst[1:], avail)
    return result

items = [('1', 3, 5), ('2', 5, 2), ('3', 10, 10), ('4', 3, 2), ('5', 4, 3), ('6', 1, 1), ('7', 3, 10)]
taken, val = fast_max(items, 20)
for item in taken :
    print(item)
print("Total value of items taken =", val)
```

1. fast_max의 반환 값은, 남은 수용량에 대해 인자로 넘겨준 영역에서 가장 높은 가치를 내는 아이템 조합입니다.

   (fast_max를 재귀적으로 사용하기 위해서는 아이템을 선택해서 새로운 영역과 그로 인한 새로운 수용양을 준비해야합니다.)

2. 가장 높은 가치를 내는 조합이 되기 위해, 아이템은 다음 두 후보 중에 하나를 선택합니다.

    1) *아이템 리스트 중 첫번째 아이템 + 첫번째를 제외한 영역에서의 fast_max함수 값* 의 조합

    2) *인자로 받은 모든 영역에서의 fast_max함수 값* 의 조합 

   cf) 첫 번째 아이템으로 가방이 넘치는 경우, 첫 번째 아이템을 제외한 영역에서 fast_max를 다시 적용합니다.  



이를 Dynamic programming으로 문제를 심화할 수 있습니다. memo라고 하는 딕셔너리를 하나 만들고, 특정 남은 수용양에 대해 특정 아이템 갯수로 이전에 계산한 적이 있다면, 이전에 계산했던 값을 반환합니다. 

```python
def fast_max(sub_lst, avail, memo={}) :
    if (len(sub_lst), avail) in memo :
        return memo[(len(sub_lst), avail)]
    if sub_lst == [] or avail == 0 :
        return (), 0
    nextitem = sub_lst[0]
    if nextitem[2] <= avail : 
        chosen1, val1 = fast_max(sub_lst[1:], avail-nextitem[2], memo)
        val1 += nextitem[1]
        chosen1 = chosen1 + (nextitem,)
        chosen2, val2 = fast_max(sub_lst[1:], avail, memo)
        if val1 > val2 :
            result = chosen1, val1
        else :
            result = chosen2, val2
    else :
        result = fast_max(sub_lst[1:], avail, memo)
    memo[(len(sub_lst), avail)] = result
    return result
```









# SQL

### 1. 차집합

프로그래머스 JOIN1.sql

```mysql
SELECT ANIMAL_ID, NAME FROM ANIMAL_OUTS
WHERE ANIMAL_ID NOT IN
    (SELECT DISTINCT ANIMAL_ID 
     FROM ANIMAL_INS);
```



### 2. 정렬

만약, VARCHAR라서 정렬을 못하는 상황이라면

```mysql

```

